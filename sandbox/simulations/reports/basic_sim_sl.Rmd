---
title: "Basic Simulations for Shift TMLEs with GLMs"
author: "Nima Hejazi and David Benkeser"
date: "`r Sys.Date()`"
output: html_document
---

```{r rmd_setup, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(echo = TRUE)
# housekeeping packages
library(here)
library(tidyverse)
library(data.table)

# packages for this simulation
library(sl3)
library(condensier)
library(shifttx)
```

### Compute TMLE for a single iteration of simulations

```{r sim_fun}
simple_shifttx_sim_sl <- function(iter, samp, delta = 0.5, censoring = FALSE,
                                  n_w, w1_prob, a1_mean, a0_mean) {

  if ((iter %% 100) == 0) {
    print(paste("Starting simulation", iter, "for sample size", samp))
  }

  ## baseline covariate -- simple, binary
  W <- as.numeric(replicate(n_w, rbinom(samp, 1, w1_prob)))

  ## set and organize treatment based on baseline W
  A1 <- rnorm(length(which(W == 1)), mean = a1_mean, sd = 1)
  A0 <- rnorm(length(which(W == 0)), mean = a0_mean, sd = 1)
  A <- rep(NA, samp)
  A[which(W == 0)] <- A0
  A[which(W == 1)] <- A1

  # create outcome
  Y <- A + W + rnorm(samp)
  
  # censoring based on covariates (DOESN'T CHANGE TRUTH?)
  if (censoring) C <- rbinom(n_obs, 1, plogis(W))

  # compute the truth from the simulation
  # \Psi(P_0) = E_0( \bar{Q}_0(A + \delta, W))
  #   = E_0(A + \delta + W)  -> definition of \bar{Q}_0
  #   = E_0(E_0(A \mid W) + \delta + W)  -> iterated expectation
  #   = \delta + P(W = 0) * (E_0(A \mid W = 0) + 0)
  #     + P(W = 1) * (E_0(A \mid W = 1) + 1)  -> defn of expectation over W
  #   = 0.5 + 0.5 * (0 + 0) + 0.5 * (2 + 1)
  #   = 2
  sim_truth = delta + (1 - w1_prob) * (a0_mean + 0) + w1_prob * (a1_mean + 1)

  # fit a TMLE
  if (!censoring) {
    tmle_shift <- tmle_shifttx(W = W, A = A, Y = Y, delta = delta,
                               fluc_method = "standard", fit_type = "glm",
                               args = list(
                                 g_fit = list(sl_lrnrs = sl_lrn_dens),
                                 Q_fit = list(sl_lrnrs = sl_lrn)
                               ))
  } else {
    tmle_shift <- tmle_shifttx(W = W, A = A, Y = Y, C = C, delta = delta,
                               fluc_method = "standard", fit_type = "glm",
                               args = list(
                                 ipcw_fit = list(sl_lrnrs = sl_lrn),
                                 g_fit = list(sl_lrnrs = sl_lrn_dens),
                                 Q_fit = list(sl_lrnrs = sl_lrn)
                               ))
  }

  # get inference for the TMLE fit
  ci_shift <- confint(tmle_shift)

  # summary statistics from TMLE procedure
  ci_in <- dplyr::between(sim_truth, ci_shift[1], ci_shift[3]) %>%
    as.numeric()
  iter_out <- list(lwr_ci = ci_shift[1], est_psi = tmle_shift$psi,
                   upr_ci = ci_shift[3], truth_in_ci = ci_in, truth = sim_truth)
  iter_out <- tibble::as_tibble(iter_out)
  return(iter_out)
}
```

### Set up parameters for parallelized simulations

```{r sim_args, message=FALSE}
# easy foreach-future parallelization
library(future)
library(doFuture)
registerDoFuture()

# best for foreach simulations
RNGkind("L'Ecuyer-CMRG")

# parameters for simulating simple data for tmle-shift sketch
n_w <- 1
w_win_prob <- 0.5
a1_mean <- 2
a0_mean <- 0
delta_shift <- 0.5

# meta-parameters for controlling simulation type
seed_int <- 9461287
n_sim <- 500
n_obs <- c(100, 1000)
```

### Setup Super Learner with `sl3`

```{r setup_sl, message=FALSE}
# SL learners to be used for most fits (e.g., IPCW, outcome regression)
lrn1 <- Lrnr_mean$new()
lrn2 <- Lrnr_glm_fast$new()
lrn3 <- Lrnr_randomForest$new()
sl_lrn <- Lrnr_sl$new(learners = list(lrn1, lrn2, lrn3),
                      metalearner = Lrnr_nnls$new())

# SL learners for conditional densities to be used for the propensity score fit
lrn1_dens <- Lrnr_condensier$new(nbins = 35, bin_estimator = lrn1,
                                 bin_method = "equal.len")
lrn2_dens <- Lrnr_condensier$new(nbins = 25, bin_estimator = lrn2,
                                 bin_method = "equal.len")
lrn3_dens <- Lrnr_condensier$new(nbins = 20, bin_estimator = lrn3,
                                 bin_method = "equal.mass")
sl_lrn_dens <- Lrnr_sl$new(learners = list(lrn1_dens, lrn2_dens, lrn3_dens),
                           metalearner = Lrnr_solnp_density$new())
```

### Fit TMLE with Super Learners *without censoring*

```{r run_sim_sl_std, message = FALSE}
# simulation
simple_sim_sl <- foreach(in_samp = seq_along(n_obs), .combine = rbind) %do% {
  # set sample size from foreach loop
  samp <- n_obs[in_samp]

  # run simulation for given sample size
  sim_results <- foreach(i = seq_len(n_sim), .combine = rbind) %dopar% {
    # set seed in foreach
    set.seed(seed_int + i)

    # run the TMLE procedure
    out <- simple_shifttx_sim_sl(iter = i, samp = samp, delta = delta_shift,
                                 n_w = n_w, w1_prob = w_win_prob,
                                 a1_mean = a1_mean, a0_mean = a0_mean,
                                 censoring = FALSE)
  }
  # compute average estimate, bias, and sd across simulations
  sim_est_mean <- mean(sim_results$est_psi)
  sim_est_var <- var(sim_results$est_psi)
  sim_est_bias <- sim_est_mean - mean(sim_results$truth)
  sim_ci_cover <- sum(sim_results$truth_in_ci) / nrow(sim_results)
  sim_out <- list(n_obs = samp, est = sim_est_mean, var = sim_est_var,
                  bias = sim_est_bias, coverage = sim_ci_cover)
  sim_samp_out <- tibble::as_tibble(sim_out)
}
```

```{r results_sim_sl_std, message = FALSE}
knitr::kable(simple_sim_sl, format = "markdown",
             caption = "Simulation statistics for shift TMLE w/ SL")
```

### Fit TMLE with Super Learners *with censoring*

```{r run_sim_sl_cens, message = FALSE}
# simulation
simple_sim_sl <- foreach(in_samp = seq_along(n_obs), .combine = rbind) %do% {
  # set sample size from foreach loop
  samp <- n_obs[in_samp]

  # run simulation for given sample size
  sim_results <- foreach(i = seq_len(n_sim), .combine = rbind) %dopar% {
    # set seed in foreach
    set.seed(seed_int + i)

    # run the TMLE procedure
    out <- simple_shifttx_sim_sl(iter = i, samp = samp, delta = delta_shift,
                                 n_w = n_w, w1_prob = w_win_prob,
                                 a1_mean = a1_mean, a0_mean = a0_mean,
                                 censoring = TRUE)
  }
  # compute average estimate, bias, and sd across simulations
  sim_est_mean <- mean(sim_results$est_psi)
  sim_est_var <- var(sim_results$est_psi)
  sim_est_bias <- sim_est_mean - mean(sim_results$truth)
  sim_ci_cover <- sum(sim_results$truth_in_ci) / nrow(sim_results)
  sim_out <- list(n_obs = samp, est = sim_est_mean, var = sim_est_var,
                  bias = sim_est_bias, coverage = sim_ci_cover)
  sim_samp_out <- tibble::as_tibble(sim_out)
}
```

```{r results_sim_sl_cens, message = FALSE}
knitr::kable(simple_sim_sl, format = "markdown",
             caption = "Simulation statistics for shift TMLE w/ SL")
```

