#' Compute the Shift Parameter Estimate and the Efficient Influence Function
#'
#' Computes the value of the treatment shift parameter as well as statistical
#' inference for the parameter based on the efficient influence function of the
#' target parameter, which takes the following form:
#' %D(P)(o) = H(a,w)(y - \bar{Q}(a,w)) + \bar{Q}(d(a,w)) - \psi(P)
#'
#' @param Y A \code{numeric} vector of observed outcomes.
#' @param Qn ...
#' @param Hn An object providing values of the auxiliary ("clever") covariate,
#'  constructed from the treatment mechanism and required for targeted minimum
#'  loss-based estimation. This object object should be passed in after being
#'  constructed by a call to the internal function \code{est_Hn}.
#' @param estimator ...
#' @param Delta Indicator for missingness. Used for compatibility with the
#'  routine to compute IPCW-TML estimates.
#' @param ipc_weights A \code{numeric} vector that gives inverse probability of
#'  censoring weights for each observation. These are generated by invoking the
#'  routines for estimating the censoring mechanism.
#' @param fluc_mod_out An object giving values of the logistic regression fit to
#'  traverse the submodel for targeted minimum loss-based estimation. This type
#'  of object should be the output of the internal routines to perform this
#'  step of the TMLE computation, as given by \code{fit_fluc}.
#' @param eif_tol A \code{numeric} giving the minimum value of the tolerance to
#'  be used in evaluating whether the computation of the efficient influence
#'  function has converged.
#'
#' @importFrom stats var
#' @importFrom dplyr if_else
#'
#' @keywords internal
#'
#' @export
#'
#' @author Nima Hejazi
#' @author David Benkeser
#
eif <- function(Y,
                Qn,
                Hn,
                estimator = c("tmle", "onestep"),
                fluc_mod_out = NULL,
                Delta = rep(1, length(Y)),
                ipc_weights = rep(1, length(Y)),
                ipc_weights_norm = rep(1, length(Y)),
                eif_tol = 1e-7) {

  # set TMLE as default estimator type
  estimator <- match.arg(estimator)

  # set Qn to use based on estimator type
  if (estimator == "tmle") {
    Qn_shift <- fluc_mod_out$Qn_shift_star
    Qn_noshift <- fluc_mod_out$Qn_noshift_star
  } else if (estimator == "onestep") {
    Qn_shift <- Qn$upshift
    Qn_noshift <- Qn$noshift
  }

  # compute TMLE of the treatment shift parameter
  param_obs_est <- rep(0, length(Delta))
  param_obs_est[Delta == 1] <- ipc_weights_norm * Qn_shift
  psi <- sum(param_obs_est)

  # compute the efficient influence function (EIF) / canonical gradient (D*)
  eif <- rep(0, length(Delta))
  eif[Delta == 1] <-
    ipc_weights * (Hn$noshift * (Y - Qn_noshift) + (Qn_shift - psi))

  # add mean of EIF to parameter estimate if fitting one-step
  if (estimator == "onestep") {
    psi <- psi + mean(eif)
  }

  # NOTE: sanity check --- EIF ~ N(0, V(D(P)(o))), so mean(EIF) ~= 0
  eif_msg <- dplyr::if_else(
    abs(mean(eif)) < eif_tol,
    paste("EIF mean <", eif_tol, "(sufficiently low)."),
    paste(
      "EIF mean =", mean(eif),
      "(higher than expected)."
    )
  )

  # compute the variance based on the EIF and scale by number of observations
  var_eif <- stats::var(eif) / length(Y)

  # return the variance and the EIF value at each observation
  out <- list(psi = psi, var = var_eif, eif = eif, msg = eif_msg)
  return(out)
}
