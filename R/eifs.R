#' Compute the Shift Parameter Estimate and the Efficient Influence Function
#'
#' Computes the value of the treatment shift parameter as well as statistical
#' inference for the parameter based on the efficient influence function of the
#' target parameter, which takes the following form:
#' %D(P)(o) = H(a,w)(y - \bar{Q}(a,w)) + \bar{Q}(d(a,w)) - \psi(P)
#'
#' @param Y A \code{numeric} vector of the observed outcomes.
#' @param Qn An object providing the value of the outcome evaluated after
#'  imposing a shift in the treatment. This object is passed in after being
#'  constructed by a call to the internal function \code{est_Q}.
#' @param Hn An object providing values of the auxiliary ("clever") covariate,
#'  constructed from the treatment mechanism and required for targeted minimum
#'  loss-based estimation. This object object should be passed in after being
#'  constructed by a call to the internal function \code{est_Hn}.
#' @param estimator The type of estimator to be fit, either \code{"tmle"} for
#'  targeted maximum likelihood estimation or \code{"onestep"} for a one-step
#'  augmented inverse probability weighted (AIPW) estimator.
#' @param Delta Indicator for missingness. Used for compatibility with the
#'  routine to compute IPCW-TML estimates.
#' @param ipc_weights A \code{numeric} vector that gives inverse probability of
#'  censoring weights for each observation. These are generated by invoking the
#'  routines for estimating the censoring mechanism.
#' @param fluc_mod_out An object giving values of the logistic regression fit to
#'  traverse the submodel for targeted minimum loss-based estimation. This type
#'  of object should be the output of the internal routines to perform this
#'  step of the TMLE computation, as given by \code{fit_fluctuation}.
#' @param eif_tol A \code{numeric} giving the minimum value of the tolerance to
#'  be used in evaluating whether the computation of the efficient influence
#'  function has converged.
#'
#' @importFrom stats var
#' @importFrom dplyr if_else
#'
#' @keywords internal
#'
#' @export
#'
#' @author Nima Hejazi
#' @author David Benkeser
eif <- function(Y,
                Qn,
                Hn,
                estimator = c("tmle", "onestep"),
                fluc_mod_out = NULL,
                Delta = rep(1, length(Y)),
                ipc_weights = rep(1, length(Y)),
                ipc_weights_norm = rep(1, length(Y)),
                eif_tol = 1e-7) {

  # set TMLE as default estimator type
  estimator <- match.arg(estimator)

  # set Qn to use based on estimator type
  if (estimator == "tmle") {
    Qn_shift <- fluc_mod_out$Qn_shift_star
    Qn_noshift <- fluc_mod_out$Qn_noshift_star
  } else if (estimator == "onestep") {
    Qn_shift <- Qn$upshift
    Qn_noshift <- Qn$noshift
  }

  # compute substitution estimator of the stochastic shift parameter
  param_obs_est <- rep(0, length(Delta))
  param_obs_est[Delta == 1] <- ipc_weights_norm * Qn_shift
  psi <- sum(param_obs_est)

  # compute the efficient influence function (EIF) / canonical gradient (D*)
  eif <- rep(0, length(Delta))
  eif[Delta == 1] <-
    ipc_weights * (Hn$noshift * (Y - Qn_noshift) + (Qn_shift - psi))

  # this will be the outcome of the extra regression
  eif_unweighted <- rep(0, length(Delta))
  eif_unweighted[Delta == 1] <-
    (Hn$noshift * (Y - Qn_noshift) + (Qn_shift - psi))

  # add mean of EIF to parameter estimate if fitting one-step
  # NOTE: the estimate of psi is updated _after_ evaluating the EIF
  if (estimator == "onestep") {
    psi <- psi + mean(eif)
  }

  # compute the variance based on the EIF and scale by number of observations
  var_eif <- stats::var(eif) / length(Y)

  # return the variance and the EIF value at each observation
  out <- list(
    psi = psi, var = var_eif, eif = eif,
    eif_unweighted = eif_unweighted
  )
  return(out)
}

################################################################################

#' Iterative IPCW Update Procedure of Efficient Influence Function
#'
#' An adaptation of the general IPCW-TMLE formulation of Rose & van der Laan as
#' well as its associated algorithm. This may be used to iteratively construct
#' an efficient IPCW-TMLE, which is computed by applying IPC weights to the
#' efficient influence function of the parameter and subsequently updating the
#' IPC weights. The efficient IPCW-TMLE estimate is provided by looping over
#' this function until convergence criteria defined over the efficient influence
#' function are satisfied (e.g., a mean of very nearly zero). For a detailed
#' description of the IPCW-TMLE, please consult Rose and van der Laan (2011)
#' <doi:10.2202/1557-4679.1217>. INTERNAL USE ONLY.
#'
#' @param data_in A \code{data.table} containing variables and observations that
#'  represent the fully observed data. That is, this is a table of the data as
#'  it is seen after a potential censoring process is applied.
#' @param C A \code{numeric} binary vector giving the censoring status of a
#'  given observation.
#' @param V A \code{data.table} giving the values across all observations of all
#'  variables that play a role in the censoring mechanism.
#' @param ipc_mech A \code{numeric} vector containing values that describe the
#'  censoring mechanism for all of the observations. Note that such values are
#'  estimated by regressing the censoring covariates \code{V} on the observed
#'  censoring \code{C} and thus correspond to predicted probabilities of being
#'  censored for each observation.
#' @param ipc_weights A \code{numeric} vector of inverse probability of
#'  censoring weights. These are equivalent to \code{C / ipc_mech} in any
#'  initial run of this function. Updated values of this vector are provided as
#'  part of the output of this function, which may be used in subsequent calls
#'  that allow convergence to a more efficient estimate.
#' @param ipc_weights_norm A \code{numeric} vector of the same weights described
#'  in the previous argument, except normalized in this case.
#' @param Qn_estim A \code{data.table} corresponding to the outcome regression.
#'  This is produced by invoking the internal function \code{est_Q}.
#' @param Hn_estim A \code{data.table} corresponding to values produced in the
#'  computation of the auxiliary ("clever") covariate. This is produced easily
#'  by invoking the internal function \code{est_Hn}.
#' @param estimator The type of estimator to be fit, either \code{"tmle"} for
#'  targeted maximum likelihood estimation or \code{"onestep"} for a one-step
#'  or augmented inverse probability weighted (AIPW) estimator.
#' @param fluc_method A \code{character} giving the type of regression to be
#'  used in traversing the fluctuation submodel. The choices are "weighted" and
#'  "standard" -- please consult the literature for details on the differences.
#' @param eif_tol A \code{numeric} providing the largest value to be tolerated
#'  as the mean of the efficient influence function.
#' @param eif_reg_type Whether a flexible nonparametric function ought to be
#'  used in the dimension-reduced nuisance regression of the targeting step for
#'  the censored data case. By default, the method used is a nonparametric
#'  regression based on the Highly Adaptive Lasso (from package \code{hal9001}).
#'  Set this to \code{"glm"} to instead use a simple linear regression model.
#'  In this step, the efficient influence function (EIF) is regressed against
#'  covariates contributing to the censoring mechanism (i.e., EIF ~ V | C = 1).
#'
#' @importFrom stats var glm qlogis fitted predict as.formula
#' @importFrom data.table as.data.table set copy
#' @importFrom assertthat assert_that
#' @importFrom dplyr "%>%" select
#' @importFrom hal9001 fit_hal
#'
#' @keywords internal
#'
#' @export
#'
#' @author Nima Hejazi
#' @author David Benkeser
ipcw_eif_update <- function(data_in,
                            C,
                            V,
                            ipc_mech,
                            ipc_weights,
                            ipc_weights_norm,
                            Qn_estim,
                            Hn_estim,
                            estimator = c("tmle", "onestep"),
                            fluc_method = NULL,
                            eif_tol = 1e-9,
                            eif_reg_type = c("hal", "glm")) {
  # perform submodel fluctuation if computing TMLE
  if (estimator == "tmle" & !is.null(fluc_method)) {
    # fit logistic regression for submodel fluctuation with updated weights
    fitted_fluc_mod <- fit_fluctuation(
      Y = data_in$Y,
      Qn_scaled = Qn_estim,
      Hn = Hn_estim,
      ipc_weights = ipc_weights[C == 1],
      method = fluc_method
    )
  } else if (estimator == "onestep" & is.null(fluc_method)) {
    fitted_fluc_mod <- NULL
  }

  # compute EIF using updated weights and updated fluctuation (if TMLE)
  # NOTE: for one-step, this adds the first half of the EIF as the correction
  #       SO the second half (from the reduced regression) is still needed...
  eif_eval <- eif(
    Y = data_in$Y,
    Qn = Qn_estim,
    Hn = Hn_estim,
    estimator = estimator,
    fluc_mod_out = fitted_fluc_mod,
    Delta = C,
    ipc_weights = ipc_weights[C == 1],
    ipc_weights_norm = ipc_weights_norm[C == 1],
    eif_tol = eif_tol
  )

  # NOTE: upon the first run of this procedure, the above two function calls
  #       have computed only the inefficient IPCW-TMLE, i.e., by fitting the
  #       initial fluctuation model and updating the EIF accordingly

  # organize EIF data for regression
  eif_data <- data_in %>%
    data.table::copy() %>%
    dplyr::select(names(V)) %>%
    data.table::as.data.table() %>%
    data.table::set(j = "eif", value = eif_eval$eif_unweighted[C == 1])

  # estimate the EIF nuisance regression using HAL
  if (eif_reg_type == "hal") {
    # if flexibility specified, just fit a HAL regression
    eif_reg_mat <- eif_data %>%
      data.table::copy() %>%
      dplyr::select(names(V)) %>%
      as.matrix()
    colnames(eif_reg_mat) <- NULL

    # fit HAL with custom arguments to get results similar to halplus
    # NOTE: this produces a warning that could be leading to serious issues...
    eif_mod <- hal9001::fit_hal(
      X = eif_reg_mat,
      Y = as.numeric(eif_data$eif),
      standardize = FALSE,
      fit_type = "glmnet",
      lambda.min.ratio = 1e-5,
      return_lasso = TRUE,
      yolo = FALSE
    )

    # compute expectation by invoking the predict method
    eif_pred_mat <- as.matrix(V)
    colnames(eif_pred_mat) <- NULL
    eif_pred <- unname(stats::predict(
      eif_mod,
      new_data = eif_pred_mat
    ))
  } else if (eif_reg_type == "glm") {
    # NOTE: change of formula to examine interactions (for debugging)
    eif_mod <- stats::glm(
      stats::as.formula("eif ~ ."),
      data = eif_data
    )

    # compute expectation by invoking the predict method
    eif_pred <- unname(stats::predict(
      eif_mod,
      newdata = V
    ))
  }

  # IPCW-TMLE: fluctuation regression to update the IPC weights
  if (estimator == "tmle") {
    ipcw_fluc_reg_data <-
      data.table::as.data.table(
        list(
          Delta = C,
          logit_ipcw = stats::qlogis(bound_precision(ipc_mech)),
          eif_reg_cov = (eif_pred / bound_precision(ipc_mech))
        )
      )

    # fit fluctuation regression
    ipcw_fluc <- stats::glm(
      stats::as.formula("Delta ~ -1 + offset(logit_ipcw) + eif_reg_cov"),
      data = ipcw_fluc_reg_data,
      family = "binomial"
    )

    # now, we can obtain Pn* from the sub-model fluctuation
    ipcw_pred <- unname(stats::fitted(ipcw_fluc))
  } else {
    # just use the initial estimates of censoring probability for one-step
    ipcw_pred <- ipc_mech
  }

  # this is the second half of the IPCW-EIF (solved by pi_n fluctuation):
  # 0 = ((C - pi_n) / pi_n) E[f(eif ~ V | C = 1)]
  ipcw_eif_component <- ((C - ipcw_pred) / ipcw_pred) * eif_pred

  # so, now we need weights to feed back into the previous steps
  ipc_weights <- C / ipcw_pred
  ipc_weights_norm <- ipc_weights / sum(ipc_weights)

  # as above, compute TMLE and EIF with NEW WEIGHTS and SUBMODEL FLUCTUATION
  # NOTE: since this is meant to update the EIF components based on the TMLE
  #       update steps, it accomplishes _literally_ nothing for the one-step
  if (estimator == "tmle") {
    # NOTE: update fluctuation with new weights prior to re-computing EIF
    fitted_fluc_mod <- fit_fluctuation(
      Y = data_in$Y,
      Qn_scaled = Qn_estim,
      Hn = Hn_estim,
      ipc_weights = ipc_weights[C == 1],
      method = fluc_method
    )

    # now, update EIF after re-fitting fluctuation with updated weights
    eif_eval <- eif(
      Y = data_in$Y,
      Qn = Qn_estim,
      Hn = Hn_estim,
      estimator = estimator,
      fluc_mod_out = fitted_fluc_mod,
      Delta = C,
      ipc_weights = ipc_weights[C == 1],
      ipc_weights_norm = ipc_weights_norm[C == 1],
      eif_tol = eif_tol
    )
  }

  # need to return output such that we can loop over this function
  out <- list(
    Qn_estim = Qn_estim,
    fluc_mod_out = fitted_fluc_mod,
    pi_mech_star = ipcw_pred,
    ipc_weights = ipc_weights,
    ipc_weights_norm = ipc_weights_norm,
    eif_eval = eif_eval,
    ipcw_eif_component = ipcw_eif_component
  )
  return(out)
}
